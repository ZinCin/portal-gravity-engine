# Portal Gravity Engine

Интерактивная симуляция потенциального поля. Решает уравнение Лапласа методом SOR (Successive Over-Relaxation). Подробнее в examples/explanation.pdf

Можно расставлять якоря, порталы, препятствия на сетке и наблюдать за результатом.

Проект был сделан больше для экспериментов с новым методом вычисления - Black-Red SOR, чем для общих экспериментов с порталами.

---

## Содержание

- [Быстрый старт](#быстрый-старт)
- [Физика](#физика)
- [Архитектура проекта](#архитектура-проекта)
- [Объекты поля](#объекты-поля)
- [Маски](#маски)
- [Параметры Simulation](#параметры-simulation)
- [Управление](#управление)
- [Цветовые схемы](#цветовые-схемы)
- [Написание сцен](#написание-сцен)

---

## Быстрый старт

**Требования:** Python 3.9+, numpy 2.0.2+, pygame 2.6.1+

**Для обычного запуска склонируйте репозиторий (или папку ./src), а затем в папку ./src запустите файл main.py**

```bash
pip install numpy pygame
python main.py
```

Для запуска другой сцены откройте `main.py` и раскомментируйте нужную строку:

```python
def main() -> None:
    sim = example_couple_portals()   # <- активная сцена
    # sim = example_advanced()
    # sim = example_couple_circles()
    sim.run()
```

или смените сцену в инспекторе

---

## Физика

Симуляция решает уравнение Лапласа:

```
∇²φ = 0
```

Метод: **Red-Black Gauss-Seidel SOR** — чередуются «красные» и «чёрные» ячейки шахматной доски, что вдвое ускоряет сходимость по сравнению с простым Якоби.

### Граничные условия

| Граница | Тип | Значение |
|---|---|---|
| Верх сетки | Дирихле | φ = 1.0 |
| Низ сетки | Дирихле | φ = 0.0 |
| Левая / правая | Нейман | ∂φ/∂n = 0 |

Верхняя и нижняя грани — постоянный источник и сток. Боковые границы прозрачны: поле свободно вытекает влево и вправо. (Это реализует гравитацию, схожую с земной)

### Начальное состояние

Потенциал инициализируется линейным градиентом φ = 1 (верх) -> 0 (низ). Это точное решение Лапласа при выбранных граничных условиях, поэтому без объектов поле не изменится. Объекты создают постоянные отклонения от этого фона.

### Параметр ω (SOR)

Управляет скоростью сходимости:

- `ω = 1.0` - медленная, но точная сходимость
- `ω = 1.5–1.9` - быстрая, но менее точная
- `ω → 2.0` - почти мгновенная, но неустойчивая

---

## Архитектура проекта

```
main.py          — точка входа
scenes.py        — готовые сцены (примеры, которые могут показать принцип работы порталов)
simulation.py    — главный класс, игровой цикл, рендеринг, UI
physics.py       — SOR-решатель
portals.py       — классы объектов поля
masks.py         — геометрические маски
colors.py        — цветовые схемы
ui.py            — виджеты боковой панели
```

> `physics.py` не зависит от Pygame, для отдельных тестов

---

## Объекты поля

Все объекты передаются в `Simulation(*field, ...)` в любом порядке и количестве.

---

### `PotentialAnchor(mask, potential_value)`

Якорь: жёстко фиксирует потенциал в своей области и удерживает его постоянно. Создаёт источник или сток поля в произвольном месте сетки.

```python
# Источник в центре сверху
PotentialAnchor(CircleMask(60, 20, 5), potential_value=1.0)

# Сток в центре снизу
PotentialAnchor(CircleMask(60, 80, 5), potential_value=0.0)
```

Якорь с φ выше фонового создаёт горку градиента потенциала, с φ ниже — яму на градиенте. Поле убывает от якоря по всем направлениям согласно уравнению Лапласа.

**Параметры:**

| Параметр | Тип | Описание |
|---|---|---|
| `mask` | `Mask` | Форма области якоря |
| `potential_value` | `float` | Фиксированное значение φ ∈ [0, 1] |
| `color` | `tuple` | RGB-цвет |
| `active` | `bool` | Включён/выключен |

---

### `FixedPotentialPortal(mask, potential_value)`

Функционально идентичен `PotentialAnchor` — фиксирует потенциал в своей области. Используется для экранирования потенциала

```python
FixedPotentialPortal(RectangleMask(20, 100, 30, 33), potential_value=0.8)
```

---

### `CouplePortal(p1, p2)`

Пара связанных порталов с **одинаковым потенциалом**. На каждом шаге потенциал по всей связанной области усредняется.

```python
p1 = Portal(RectangleMask(25, 75, 25, 26), color=(255, 153, 0))
p2 = Portal(RectangleMask(25, 75, 94, 95), color=(0, 204, 255))
couple = CouplePortal(p1, p2)
```

**Параметры `Portal`:**

| Параметр | Тип | Описание |
|---|---|---|
| `mask` | `Mask` | Форма портала |
| `color` | `tuple` | RGB-цвет |
| `active` | `bool` | Включён/выключен |

---

### `MaterialObject(mask, ...)`

Твёрдое препятствие. Ячейки внутри **исключены из SOR**. Т.е. поле огибает объект снаружи. Потенциал внутри фиксируется начальным значением и не обновляется.

```python
# Неподвижный куб
MaterialObject(
    RectangleMask(40, 80, 40, 60),
    color=(180, 180, 180),
    pinned=True,
    label="Block"
)

# Свободный шар
MaterialObject(
    CircleMask(cx=60, cy=50, radius=8),
    pinned=False,
    mass=1.5
)
```

**Параметры:**

| Параметр | Тип | По умолчанию | Описание |
|---|---|---|---|
| `mask` | `Mask` | — | Форма объекта |
| `color` | `tuple` | `(180, 180, 180)` | RGB-цвет |
| `pinned` | `bool` | `False` | Если `True` нельзя перетащить |
| `label` | `str` | `"Object"` | Имя в UI |
| `mass` | `float` | `1.0` | Масса |
| `active` | `bool` | `True` | Включён/выключен |

---

### `ConductorObject(mask, ...)`

Плавающий проводник. На каждом шаге потенциал внутри объекта выравнивается по среднему потенциалу внешних соседних ячеек. Создаёт характерное для проводника искажение силовых линий.

```python
ConductorObject(
    CircleMask(cx=60, cy=50, radius=10),
    color=(220, 180, 60),
    pinned=True,
    label="Sphere"
)
```

Параметры аналогичны `MaterialObject`.

---

## Маски

Маски определяют геометрическую форму объекта на сетке симуляции. Любой объект принимает любую маску.

### `RectangleMask(x_min, x_max, y_min, y_max)`

```python
RectangleMask(10, 90, 20, 21)   # тонкая горизонтальная полоса
RectangleMask(0, 120, 0, 1)     # якорь по всему верхнему краю
```

### `CircleMask(cx, cy, radius)`

```python
CircleMask(cx=60, cy=50, radius=15)
```

### `PointMask(x, y)`

Одна ячейка сетки.

```python
PointMask(60, 50)
```

### `LineMask(x1, y1, x2, y2, thickness)`

Отрезок между двумя точками с заданной толщиной.

```python
LineMask(10, 10, 110, 90, thickness=2.0)
```

### `PolygonMask([(x0,y0), (x1,y1), ...])`

Произвольный многоугольник.

```python
PolygonMask([(30, 20), (90, 20), (60, 80)])  # треугольник
```

### `FunctionMask("выражение")`

Маска, заданная произвольным выражением (функцией). Переменные: `x`, `y`, `np`. Выражение должно возвращать булев скаляр или массив.

```python
FunctionMask("(x - 60)**2 + (y - 50)**2 < 15**2") # круг
FunctionMask("np.abs(x - 60) < 5")т # вертикальная полоса
FunctionMask("(x > 30) & (x < 90) & (y > 40) & (y < 60)")  # прямоугольник
```

> ⚠️ `PolygonMask` и `FunctionMask` вычисляются медленнее остальных вследствие сложных вычислений, не используйте их без надобности.

---

## Параметры Simulation

```python
Simulation(
    *field,                          # объекты поля (любое количество)
    sim_width: int,                  # ширина сетки в ячейках
    sim_height: int,                 # высота сетки в ячейках
    px_scale: float,                 # пикселей на ячейку
    iterations_per_frame: int = 50,  # SOR-итераций за кадр
    diff_threshold: float = 1e-6,    # порог досрочной остановки
    view_mode: str = "g_force",      # "g_force" | "potential"
    show_vectors: bool = True,       # векторы градиента
    show_isolines: bool = True,      # изолинии
    isoline_count: int = 10,         # количество изолиний
    fps: int = 60,                   # целевой FPS
    sor_omega: float = 1.7,          # параметр SOR [1.0, 2.0)
    color_mapper = None,             # кастомная цветовая схема
)
```

**Рекомендуемые размеры сетки:**

| Разрешение | `px_scale` | Нагрузка |
|---|---|---|
| 80 × 80 | 8 | малая |
| 120 × 120 | 6 | средняя (по умолчанию) |
| 200 × 150 | 4 | большая |

---

## Управление

### Клавиатура

| Клавиша | Действие |
|---|---|
| `M` | Переключить режим отображения гравитационное ускорение / потенциал |
| `V` | Показать / скрыть векторы градиента |
| `I` | Показать / скрыть изолинии |

### Мышь

| Действие | Результат |
|---|---|
| **ЛКМ + перетащить** по порталу или объекту | Переместить объект |
| **ПКМ** по объекту | Открыть инспектор в панели SCENE |

### Боковая панель

**Вкладка SIMULATION** - параметры рендеринга и физики в реальном времени:

- Режим отображения (сила / потенциал)
- Векторы, изолинии, количество изолиний
- Цветовая схема
- Iterations per frame, SOR ω

**Вкладка INSPECTOR** - управление объектами:

- Добавить портал, якорь, объект, проводник
- Пресеты сцен
- Инспектор выбранного объекта (параметры маски, цвет, значение φ)

---

## Цветовые схемы

Доступны в `COLOR_SCHEMES` и переключаются в панели SIMULATION:

| Название | Описание |
|---|---|
| `Default` | Синий → зелёный → жёлтый → красный (для g_force) |
| `Potential` | Синий → зелёный → красный (для potential) |
| `Plasma` | Фиолетовый → розовый → жёлтый |
| `Electric` | Чёрный → синий → белый |
| `Fire` | Чёрный → красный → золотой → белый |
| `Extra` | Синий → бирюзовый → жёлтый → красный |

Кастомная схема задаётся через `color_mapper`:

```python
from colors import GradientColorMapper

my_mapper = GradientColorMapper([
    (0.0, (0,   0,  50)),   # тёмно-синий при φ = 0
    (0.5, (255, 255, 0)),   # жёлтый при φ = 0.5
    (1.0, (255,  50, 50)),  # красный при φ = 1
])

sim = Simulation(..., color_mapper=my_mapper)
```

---

## Написание сцен

Все сцены определяются в `scenes.py`. Минимальная сцена:

```python
from simulation import Simulation
from portals import PotentialAnchor, CouplePortal, Portal
from masks import RectangleMask, CircleMask

def my_scene() -> Simulation:
    W, H = 120, 120

    # Якоря задают фоновое поле
    top    = PotentialAnchor(RectangleMask(0, W, 0, 1),      1.0)
    bottom = PotentialAnchor(RectangleMask(0, W, H-1, H),    0.0)

    # Два связанных портала
    p1 = Portal(CircleMask(30, 60, 10), color=(255, 153, 0))
    p2 = Portal(CircleMask(90, 60, 10), color=(0, 204, 255))

    return Simulation(
        top, bottom, CouplePortal(p1, p2),
        sim_width=W, sim_height=H,
        px_scale=6,
        iterations_per_frame=40,
        sor_omega=1.7,
    )
```

Затем в `main.py`:

```python
from scenes import my_scene

def main():
    my_scene().run()
```

### Рецепты

**Два якоря вместо граничных условий сетки:**

```python
# Источник сверху, сток снизу — поле направлено вниз
PotentialAnchor(RectangleMask(0, W, 0, 1),   1.0)
PotentialAnchor(RectangleMask(0, W, H-1, H), 0.0)
```

**Два параллельных экрана:**

```python
FixedPotentialPortal(RectangleMask(20, 100, 30, 33), 0.8)
FixedPotentialPortal(RectangleMask(20, 100, 67, 70), 0.2)
```

**Проводник в поле экрана:**

```python
ConductorObject(CircleMask(60, 50, 10), pinned=True, label="Sphere")
```

**Непроводящее препятствие:**

```python
MaterialObject(RectangleMask(50, 70, 30, 70), pinned=True, label="Wall")
```

---

**Для подробного объяснения симуляции прочитайте explanation.pdf**
